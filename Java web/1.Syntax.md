



# Use [Jshell]() to learn the syntax
- Read-Eval-Print Loop (REPL):  evaluates and then immediately shows the results. 
- JShell is a standard component of the JDK.
```bash
#bash
jshell
```

|||
|-|-|
|\<tab> completion||
|/vars |variable list|






# Basic
### starter
- Every line of code that runs in Java must be inside a class. 
- A class should always start with an uppercase first letter.
- ; at end of line
- use `{}` in code block like c++
- every program must contain the `main()` method as entry point.
- start every file with package declaration
```java
package java.lang;
```
### basic I/O:
```java
System.out.println("Hello World!")  // will insert new line at the end
System.out.print("Hello World!");
```


# Operators
- [refs](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html)
## Basic operators
### Arithmetic 

|||||
|--|--|--|--|
|+|-|*|/|
|%|++|--||

### Assignment 

||| | |
|--|--|--|--|
|=|+=	|-=|*=|
|/=|%=|	

### compare

||| | |
|--|--|--|--|
| == | !=	| >/>= | </<= |

|||
|--|--|
| `instanceof` | Compares an object to a reference type|

### Conditional


||| 
|--|--|
| && | \|\|	| 
| ?: |Ternary: (shorthand for if-then-else statement)|


### bitwise and bit shift operators
> They are really only needed for things like hardware programming in drivers and low level network programming. 

> I've only have used bitwise shifting for creating my own hash function. You might need it for fancy bit-twiddling but that's rare too. Maybe for cryptography.


## `Lambda Expression ->`
```java
List<String> items = List.of("1", "a", "2", "a", "3", "a");
items.forEach(item -> {
    if (item.equals("a")) {
        System.out.println("A");
    } else {
        System.out.println("Not A");
    }
});
```
# General keywords
### `package`
```java

package java.lang;
```

### `import`
- import 
  - packages or 
  - classes within package or
  - static variables/methods
- wildcard(compact) import possible: `*`
  - import any visible type from the package
```java
import java.lang.Math;
import static java.lang.Math.PI;
import static java.lang.Math.*;
```
- static variables/methods are var/methods that can be used without construct an object

### `@annotations`
Java annotations are a way to add metadata information to Java classes, methods, and fields. They are similar to comments, but they are meant to be processed **by the compiler** or by other tools at **runtime**.

> a component is labeled as something another component recognizes and does specific operations with it



Here is an example of a simple annotation:

```java
@Author(name = "John Smith")
public class MyClass {
    // class code here
}
```
In this example, the **@Author** annotation is used to specify the name of the author of the class. This annotation can then be processed by a tool or framework to generate documentation or to perform other tasks.

Annotations can also include parameters. Here's an example of an annotation with parameter:

```java
@SuppressWarnings(value = "unchecked")
public void myMethod() {
   // method code here
}
```
In this example, the **@SuppressWarnings** annotation is used to **suppress specific warnings** that the compiler may generate when it checks the method. The value **parameter** of this annotation takes an array of strings specifying the types of warnings to suppress.

 **Java provides a set of predefined annotations** called "built-in annotations" like @Override, @Deprecated, @SuppressWarnings etc.

Annotations are **widely used in frameworks** such as Spring, Hibernate, JUnit, and many others.


# Control Flow
## Conditional

|||
|--|--|
|if...else||
|else if||
|?:| (condition) ? expressionTrue :  expressionFalse; |
|switch||

- ternary
```java
int time = 20;
String result = (time < 18) ? "Good day." : "Good evening.";
```
- switch
```java
switch(expression) {
  case a:
    // code block
    break;
  case b:
    // code block
    break;
  default:
    // code block
}

```
- When Java reaches a `break` keyword, it breaks out of the switch block. When a match is found, and the job is done. There is no need for more testing.
- The `default` keyword specifies some code to run if there is no case match:

## Iterations
[ways-to-iterate-through-a-list](https://crunchify.com/how-to-iterate-through-java-list-4-way-to-iterate-through-loop/) 

|||
|--|--|
| while |  |
| do...while |  |
| for/ for...in |  |
| `Iterable.forEach()` |  |
| [`iterator`](https://www.javatpoint.com/java-iterator#:~:text=In%20Java%2C%20an%20Iterator%20is,the%20Java%201.2%20Collection%20framework.) |  |

|||
|--|--|
|break|continue|

```java
List<String> cars = Arrays.asList("Volvo", "BMW", "Ford", "Mazda");
```
### whiles
```java
// while
int i = 0;
while (i < cars.size()) {
  System.out.println(cars.get(i));
  i++;
}
// do...while
int i = 0;
do {
  System.out.println(cars.get(i));
  i++;
}
while (i < cars.size());
```
### for loop
```java
// for
for (int i = 0; i < cars.size(); i++) {
  System.out.println(cars.get(i));
}
// for...in
for (String i : cars) {
  System.out.println(i);
}
```
### forEach
```java
cars.forEach(car -> {
  System.out.println(car);
})
```
### iterators
- Iterator vs ListIterator: 
  - An `Iterator` is an interface in Java and we can traverse a list in a `forward direction`. 
  -  `ListIterator` is an interface that **extends the Iterator** interface and we can traverse in `both forward and backward` directions.
- belongs to java.util package, iterator is universal for all the classes of the Collection framework 
```java
Iterator<String> carsIterator = cars.iterator();
ListIterator<String> carsListIterator = cars.listIterator();

// iterator
while (carsIterator.hasNext()) {
    System.out.println(carsIterator.next());
}
// ListIterator
while (carsListIterator.hasNext()) {
    System.out.println(carsListIterator.next());
}
```

## Error handling 

### `throws` and `throw` keyword [link](https://rollbar.com/blog/how-to-use-the-throws-keyword-in-java-and-when-to-use-throw/) 
- The `throws` keyword  declare  exceptions to be thrown **from a method**, while the `throw` keyword is used to `explicitly throw` an exception **within a method or block of code**.


- `throws` allows exception to propogate up the call stack, allows exceptions to not necessarily be handled within the method.
  - For any method that can throw exceptions, it is mandatory to use the throws keyword to list the exceptions
  - the exception will be provided to the caller of the method
  - thus allows exceptions to be propagated in the call stack

- !! Only `checked exceptions (Exception)` are required to be thrown using the throws keyword. `Unchecked exceptions(RuntimeException)` don’t need to be thrown or handled explicitly in code.

```java
public static void writeToFile() throws Exception1, Exception2, …  {
  // implementation 
}
```
### `try-catch-finally` syntax
```java
try {
  [code_block]
} catch ([exception_block]} {
  [handling_code_block]
} finally {
  [cleanup_code_block]
}
```
- `finally block`: Optional, when present, this block of code is executed regardless of whether an exception is thrown or not.

```java
public class ExceptionDemo {
    public static final int arr[] = {5, 1, 4, 2, 3};
    public static void main(String... args) {
        try {
            checkNotEven(arr);
            System.out.println("Not found, all good!");
        } catch (EvenException e) {
            // handle exception
            System.out.println(e.getMessage());
        } finally {
            System.out.println("Cleaning up arr");
            for (int i = 0; i < arr.length; ++i) {
                arr[i] = 0;
            }
        }
    }
    public static checkNotEven (int... arr) throws EvenException {
        for (int i = 0; i < arr.length; ++i) {
            if (arr[i]%2 == 0) {
                throw new EvenException("Did not expect an even number")
            }
        }
        return -1; 
    }
}

```
- Group together similar types of exceptions that are treated the same way using the `|(pipe)` symbol. 
- can use multiple catch block, though try to avoid unnecessary usage

```java
ErrorContainter errorContainer = new ErrorContainter();
try {
  validate(report);
} catch (FileNotFoundException | NotParsable e) {
  errorContainer.addBadFileError(e);
} catch (InvestmentMaxException e) {
  errorContainer.addInvestmentError(e);
} finally {
  if (errorContainer.isEmpty()) {
    printValidationPassedDocument();
  } else {
    printValidationFailedDocument(errorContainer);
  }
}
```


### `try with Resources` syntax [link](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)
- it is `try` statement that declares one or more `resources`.
- A `resource` is an object that must be closed after the program is finished with it. 
- The `try-with-resources` statement ensures that **each resource is closed at the end of the statement (either error occurs or not).** 
  - It eliminate the need to use `finally` to manually close the resource.
  - it prevent possible resource leak using `finally`


- The following example reads the first line from a file. 
  - It uses `resources` : FileReader and BufferedReader to read data from the file. 
  - the resources `must be closed` after the program is finished with it:
- The classes `FileReader` and `BufferedReader` implement the interface `java.lang.AutoCloseable`. Anything that implement the interface can be used as resource in `try-with-resources` Statement
```java
static String readFirstLineFromFile(String path) throws IOException {
	    try (FileReader fr = new FileReader(path);
	         BufferedReader br = new BufferedReader(fr)) {
	        return br.readLine();
	    }
	}

// equal to
...
finally {
        br.close();
        fr.close();
    }
```

- closing resource with `try-with-resources` may create `Suppressed Exceptions`, more read on [java docs](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)

### [Custom Exceptions](https://www.baeldung.com/java-new-custom-exception) 
- Java exceptions cover almost all general exceptions
- main reasons for introducing custom exception
  - Business logic exceptions
  - to dealt subsets of existing Java exceptions

- Exception(Checked) vs RuntimeException(Unchecked) [link](https://stackoverflow.com/questions/2190161/difference-between-java-lang-runtimeexception-and-java-lang-exception)
  - `Exception` are something that you cannot avoid and are instead required to deal with them after the fact (for example: remote error).
  - `RuntimeExceptions` are exceptions that can be prevented programmatically (eg: If you check for null before calling any method, NullPointerException would never occur)
- These days people favor RuntimeException, (some use it for everything) 
  - it is not checked by the compiler, so it is clean code.
  - it is compatible to Java 8 Lambda processing
- Checked exception requires extend the `java.lang.Exception`class

```java
// exception
public class IncorrectFileNameException extends Exception { 
    public IncorrectFileNameException(String errorMessage, Throwable err) {
        super(errorMessage);
    }
}
// use the exception
try (Scanner file = new Scanner(new File(fileName))) {
    if (file.hasNextLine()) {
        return file.nextLine();
    }
} catch (FileNotFoundException err) {
    if (!isCorrectFileName(fileName)) {
        throw new IncorrectFileNameException(
          "Incorrect filename : " + fileName , err);
    }
    // ...
}
```
- Unchecked exception requires extend the `java.lang.RuntimeException` class 

```java
public class IncorrectFileExtensionException 
  extends RuntimeException {
    public IncorrectFileExtensionException(String errorMessage, Throwable err) {
        super(errorMessage, err);
    }
}
```
# TODO
