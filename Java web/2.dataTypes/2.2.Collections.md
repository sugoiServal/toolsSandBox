## stack and heap memory
- `stack` memory
  - create for each method call
  - store primitive local variables and references to objects( in the heap.). Each ref consume 8 bytes in 64bit system. 
  - Each JVM execution thread has its own stack memory. Size can be specified using `JVM parameter -Xss`
  - `java.lang.StackOverflowError` (eg: recursion without termination)

- `heap` memory
  - allocate memory for developor defined objects and JDK classes 
  - includes any object that created with `new` keyword
  - Objects created inside the heap memory can be accessed by all threads of the application.
  - heap depends in the available physical memory, `java.lang.OutOfMemoryError` (eg, loading huge dataset)

## Parameter Passing mechanism
### primitive types
- primitive types are passed by value: 
  - `copies of primitive values` (e.g., values of int and double)
  - When a method modifies a `primitive-type` parameter, changes to the parameter have `no effect on the original argument value` in the calling method.
### reference types
- The Java Spec says that `everything in Java is pass-by-value`(includes the reference itself). There is no such thing as "pass-by-reference" in Java.
  - passing `copies of references(aka address)`
- What they call "references" act/feel more like what we'd call "pointers" (address) in most other languages. 
  - References are basically (in this context) syntactic sugar that hide the pointer from user
```java
// essentially passing the address of the created Dog object to the foo method
Dog myDog = new Dog("Rover");
foo(myDog);
```
- a reference created inside a scope will impact not impact reference outside the scope
  - that is because the reference `someDog` is a copy to the reference `myDog`
```java
Dog myDog = new Dog("Rover");  // at adress 42

public void foo(Dog someDog) {
    someDog.setName("Max");    // dog at adress 42 modified 
    someDog = new Dog("Fifi");  // at adress 42
    someDog.setName("Rowlf");   
}
myDog   // still point at adress 42 
```

## Garbage Collection [reading](https://newrelic.com/blog/best-practices/java-garbage-collection#:~:text=Garbage%20collection%20in%20Java%20is,be%20executed%20by%20a%20JVM.)
- java provide automatic Garbage Collector
  - When objects are no longer needed, the garbage collector finds and tracks these `unused objects` and deletes them to free up space

> The garbage collector uses a `mark-and-sweep algorithm` to mark all `unreachable objects` as garbage collection, then scans through live objects to `find objects that are still reachable`

- the process:
  - the collector `scans the heap`: looking for object with `0 reference`
  - the collector removes the object, freeing up memory
- `memory leak` still potentially occurs!
  - user code `continues to reference the object` even it's `no longer being used`
  - when it occurs, the problem is generally hard to detect

### The mark-and-sweep algorithm
1. Java partition heap into three parts:
   - `Eden`: newly created object, short live object
     - most frequently scaned
     - when full, there will be a scan:
       - unrefed object => remove
       - long TTL => move to the `Survivor`
   - `Survivor`:there are two level of `Survivor` space: zero and one
     - less checked compare to Eden
   - `Tenured`: where long-lived objects are stored
     - Objects are eventually moved to this space if they survive a certain number of garbage collection cycles
     - it is least checked space

### optimize (performance) garbage collection
 - changing the garbage collector you use
 - removing all references to unused Java objects
 - using an application monitoring tool to optimize performance
 
[collections framework](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)

.getClass()


## containing types
[link](https://stackoverflow.com/questions/47838841/hashtable-hashmap-hashset-hash-table-concept-in-java-collection-framework)

## Array


### Array vs ArrayList
- In Java, `Array` is a basic functionality whereas `ArrayList` is a part of the collection framework

- `Array` is fixed size, `ArrayList` is dynamic size
  - ArrayList can be seen as `Vector` in c++
### map
- hashtable(old imple, deprecated)
- hashmap
- HashSet
