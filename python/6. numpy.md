``` python
import numpy as np

# find api/reference
    np.array?                   # get doc
    np.lookfor('create array')  # find API
    np.con*?                    # wildcard search

# create array
    a = np.array([0, 1, 2, 3])
    a = np.array([[0, 1, 2], [3, 4, 5]])
    a = np.arange(10)                           # 0-9
    a = np.linspace(0, 1, 6)                    # even space: start, end, num-points
    a = np.ones((3, 3))                         # all 1 metrix
    a = np.zeros((3, 3))                        # all 0 metrix
    a = np.eye(3)                               # eye (3 *3)
    a = np.diag(np.array([1, 2, 3, 4]))         # diagonal (4 *4)

    a = np.random.rand(4)                       # uniform (1 *4)
    a = np.random.randint(low=1, high=10, size=5)  # random integer
    a = np.random.randn(4)                      # Gaussian (1 *4)
    np.random.seed(1234)                        # set random seed

# get dim 
    a.ndim
    a.shape
    np.shape()
    len(a)

# slicing (create view)
    # 1d
    a[2:5:1]            # [start:end:step], range: [2, 5)
    a[::2]              # default: start= 0, end= -1, step- 1 
    # 2d
    a[0, 3:5]           # slice [3:5] in first row
    a[4:, 4:]           # slice [4:] from 4th to last row (as a matrix, those from same row form a row)
```
## view and copy
- slicing operation, upon assign creates a **view** on the original array for read and write. It is still the same object
- .copy() method force deep copy
- fancy slcing operation, upon assign create a **copy**
```python
# check if two arraies is the same object
    np.may_share_memory(arr_a, arr_b)
# normal slicing 
    a = np.arange(10)
    b = a[::2]                          # view, same object
    c = a[::2].copy()                   # force copy create different object
    np.may_share_memory(a, b)           # true
    np.may_share_memory(a, c)           # false
```

```python
# fancy slicing(create copy if assign)
    # through mask
        a = np.random.randint(low=1, high=10, size=5)
        mask = (a % 3 == 0)

        a[mask] = 100                       # no assignment, same object (id(a) does not change)
        b = a[mask]                         # assign to b, b is a copy
        np.may_share_memory(a, b)           # false
        a[a % 3 == 0] = 1                   # concise writing

    # through index array
        a = np.arange(0, 10)
        a[[9, 7]] = -100                    # no assignment, same object (id(a) does not change)
        b = a[[9, 7]]                       # assign to b, b is a copy
    
    # 2d fancy slicing
        a[3:5, [0, 2, 5]]                   # 2 rows(3-4), 3 column (from 0, 2, 5 col of a)
                
```