# Tools

- `minikube`: minikube run Kubernetes cluster locally(single host). Education and Local development.

  - create a `virtual box` in host
  - create/run nodes in the virtual box

```bash
# install https://minikube.sigs.k8s.io/docs/start/
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# start a cluster
minikube start # create a cluster
minikube stop # stop a cluster
minikube delete # delete a cluster

# troubleshooting
minikube status # check cluster running status
minikube ip # ip address that minikube run
```

## ctls

- `API Server` tools

  - `kubectl`: The Kubernetes command-line tool.
  - APIs
  - kubernete Dashboard(GUI)

- `containerd` tools

  - `nerdctl`: community made, provide all docker UX for containerd.
  - ctr (not much used): come with containerd, very limit function, main usage is debug containerd

- Kubernetes CRI tool
  - [crictl](https://kubernetes.io/docs/tasks/debug/debug-cluster/crictl/): (not much used) main usage is debug container runtime

### Tldr

- I would use
  - kubectl for k8s admin tasks
  - nerdctl for general container tasks, with usage like docker ctl
  - crictl

# nerdctl

- You can basically use nerdctl by replacing Docker commands' `docker` with `nerdctl`

# kubectl

- [kubectl cheatsheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)

## alias

```bash
alias k='kubectl'
alias h='history'
# <-- Create a YAML template
alias krdr="kubectl run --dry-run=client -o yaml"
alias kcddr="kubectl create deployment --dry-run=client -o yaml"

# TODO
alias kg='kubectl get'
alias ke='kubectl edit'
alias kd='kubectl describe'
alias kdd='kubectl delete'
alias kgp='kubectl get pods'
alias kgd='kubectl get deployments'
alias kns='kubens'
alias kcx='kubectx'
alias wkgp='watch kubectl get pod'
```

- .vimrc(TODO)

```bash

```

- handy commands

```bash
# create resource directly from image
k run nginx --image=nginx
k create deployment --image=nginx nginx

# generate a template to a yaml file
krdr my-nginx --image=nginx > ngx.yaml
kcddr my-nginx-deploy --image=nginx --replicas=4 > ngx-deploy.yaml

# k create deployment-name --image=nginx nginx --replicas=4 --dry-run=client -o yaml > nginx-deployment.yaml

# What is the Image/Status/Label/IP used to create the nginx?
k describe pod nginx | grep "Image"

# delete resource
k delete pod webapp
```

- manage resource

```bash

kubectl apply -f mongo.yaml  # create or update a resource of the resource exist
kubectl apply -f webapp.yaml
kubectl create -f webapp.yaml  # create a new resource, return an error if resource exist

# kubectl apply are preferred over kubectl create:
  # most of the time you care about resource being at a certain state at a point in time


## get basic info about k8s resource
kubectl get node
kubectl get node -o wide # extended info
kubectl get pod
kubectl get svc  # service
kubectl get all

## get detailed info about a specific resource
kubectl describe svc {svc-name}
kubectl describe pod {pod-name}

## Delete resource
kubectl delete pod <pod-name> # Delete pods and services with same names
kubectl delete pods -l <labelName>  # Delete pods and services with labelName
kubectl delete pods,services -l name=myLabel   # Delete pods and services together

```

- TODO

```bash
## get application logs

kubectl logs {pod-name}

# List information about a resource with more details:

kubectl get pod|service|deployment|ingress|... -o wide

# Update specified pod with the label 'unhealthy' and the value 'true':

kubectl label pods name unhealthy=true

# List all resources with different types:

kubectl get all

# Display resource (CPU/Memory/Storage) usage of nodes or pods:

kubectl top pod|node

# Print the address of the master and cluster services:

kubectl cluster-info

# Display an explanation of a specific field:

kubectl explain pods.spec.containers

# Print the logs for a container in a pod or specified resource:

kubectl logs pod_name

# Run command in an existing pod:

kubectl exec pod_name -- ls /

```
