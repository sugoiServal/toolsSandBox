- configuration is declarative using `yaml configuration file`

  - user define the desired running state,
  - k8s constantly try to meet the desired state
  - a state is defined by the etcd data

## Fields

- `kind`, `apiVersion`

|                       |         |
| --------------------- | ------- |
| Pod                   | v1      |
| Service               | v1      |
| ReplicationController | v1      |
| ReplicaSet            | apps/v1 |
| Deployment            | apps/v1 |

- `metadata`: metadata regarding the configuration

```yml
metadata:
  name:
  labels: # a dictionary containing arbitrary key-value
  namespace:
```

- `spec`: content determined by the `kind`

```yml
# pod
containers: # an array of containers definition
  - name: nginx
    image: nginx:latest
    ports:
      - containerPort: 80
    env:
      - name: SOME_ENV
        value: $SOME_ENV
---
# replicasset/ deployment
replicas:

selector:
  matchLabels: # a dictionary containing arbitrary key-value

template:
  # a nested pod definition
---
# service
type: # NodePort, ClusterIP, LoadBalancer, ExternalName, HeadLiness
ports:
  - targetPort: 80
    port: 80
    nodePort: 30008 # 30000-32767
selector:
  matchLabels: # a dictionary containing arbitrary key-value
clusterIP: # optional: <not defined>, <IP>, None
sessionAffinity: # ClientIP, None
externalName: # for ExternalName: external service IP/DomainName
---
```

# pod

```yaml
apiVersion: v1
kind: Pod
metadata:
  name:
  labels:
    app: nginx
    type: backend
  namespace: dev
spec:
  containers: # an array of containers
    - name: nginx
      image: nginx:latest
      ports:
        - containerPort: 80 # which port a container open
    - name: nginx-helper
      image: my-nginx-helper
      ports:
        - containerPort: 81
```

## ReplicaSet/ Deployment

- `selector` is used to filter through pods by label
- `template` is used to spawn new resource for replicas

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: my-replicaset
  labels:
    app: my-app
spec:
  replicas: 3
  selector: # ReplicaSet have one more selector field over ReplicationController
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-container
          image: nginx:latest
          ports:
            - containerPort: 80
```

- deploy a ReplicationController

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: myapp-rc
  labels:
    app: my-app
    type: front-end
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-container
          image: nginx:latest
          ports:
            - containerPort: 80
```

- deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
  labels:
    app: my-app
    type: front-end
spec:
  replicas: 3
  selector: # select the target
    matchLabels: # what labels will be affected by this config
      app: my-app
  template: # pod's template (a nested POD config without `apiVersion` and `kind`)
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: my-app
          image: my-image
          env:
            - name: SOME_ENV
              value: $SOME_ENV
          ports:
            - containerPort: 8080
```

## Service

- NodePort

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  type: NodePort
  ports:
    - targetPort: 80 # pod's port
      port: 80 # service port, mandatory
      nodePort: 30008 # optional: pick random available port from 30000 to 32767
  selector:
    app: my-app
    type: front-end
```

- ClusterIP

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend
spec:
  type: ClusterIP
  sessionAffinity: <ClientIP/ None> # set session affinity
  ports:
    - targetPort: 80 # same as the port you expose in pod definition
      port: 80 # the service port
  selector: # filter pods that use this ClusterIP
    app: my-app
    type: front-end
```

- ExternalName

```yaml
#  <service-name>.<namespace>.svc.cluster.local:port
apiVersion: v1
kind: Service
metadata:
  name: your-external-service
spec:
  type: ExternalName
  externalName: www.google.com # DNS name/IP
  ports:
    - port: 80 # Port number that the service will be available on within the cluster
```

# Namespaces

- namespace

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: dev
```

- ResourceQuota

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev # which namespace the quota applies to
spec:
  hard:
    pods: "10"
    requests.cpu: "4"
    requests.memory: 5Gi
    limits.cpu: "10"
    limits.memory: 10Gi
```

# Ingress

```yml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-ingress
  namespace: default
  annotations: #  an annotation for the Nginx Ingress controller to rewrite the URL path.
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules: # host + url path => service:port
    - host: nginx.example.com # Replace with your domain or hostname
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: nginx-service
                port:
                  number: 80
```
