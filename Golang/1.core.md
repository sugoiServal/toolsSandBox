# Prepare

- learning resource

  - [comprehensive tutorial](https://www.youtube.com/watch?v=un6ZyFkqFKo)
  - [todo various application](https://www.youtube.com/watch?v=jFfo23yIWac)
  - [todo microservice](https://www.youtube.com/watch?v=VzBGi_n65iU&list=PLmD8u-IFdreyh6EUfevBcbiuCKzFk0EW_)

- go

  - go is a compiled language, compile to native machine code.
  - runtime faster that all interpret languages (python, javascript, ruby)
  - rumtime similar to VM-based languages like Java, C#.
  - go tend to use much less memory
    - built-in automatic GC
    - go inject a `runtime` code in compile that integrated with GC functions
    - doesn't require the huge memory overhead of VM (like Java JVM)
  - go has fastest compiling speed
  - go syntax similar to C
  - go is strong typed and static typed

- tldr:
  - auto GC, and light-weight runtime
  - Java/C# level efficiency
  - compile to binery
  - very powerful `Concurrency Model`
  - C++/C like, not entirely OOP
  - great for
    - APIs(thanks to concurrency model)
    - Microservices, great for containers (thanks to lightweightness)
    - Networking: (offers low-level network programming capabilities, UDP/TCPIP)
    - SystemOps, Data ETL... (efficiency)

### [install](https://go.dev/doc/install)

- vscode go extension

### Naming convension

- `Package` Names: typically one lowercase word or a short abbreviation
- `Exported (Public)` Names: starts with an `Uppercase` letter, `exported` objects can be accessed from other packages.
- Unexported (Private) Names: starting with a `lowercase` letter. unexported object can only be accessed within the same package
- function/variable are in general `camelCase`

```go
// package
package main
package utils
package http

// Exported
var MaxValue int
func CalculateSum(a int, b int) int
type Point struct {...}

// Unexported
var count int
func calculateAverage(numbers []int) float64
type point struct {...}

// camelCase function/variable name
func calculateSum(a int, b int) int
func processHTTPRequest(request Request) (Response, error)
var count int
var userName string

// Interface/ Type/ const start with Uppercase
type User struct {...}
type Products []Product
type Reader interface {
    Read([]byte) (int, error)
}
const (
    MaxRetryCount = 3
    PI            = 3.14159265359
)
```

# Get Started

### Module: Project Initialization

- `module`: is basically project
- `go mod init`
  - go mod init create a new module
  - initialize a `go.mod` file
    - module name
    - dependencies, versions

```bash
# go mod init create a new module
go mod init <prj_name>
```

### Go commands

```bash
 # compiles and run the file (must be func main)
go run <file.go>

# Download and install a package
go get <package_path>

# Compile the package present in the current directory
go build

# Execute all test cases of the current package (files end with _test.go)
go test

# Compile and install the current package
```

# Basic keywords, fmt

- `package`:
  - all go code must belongs to a package
  - a package is many src files
- `import`:
  - import packages
  - [go standard lib](https://pkg.go.dev/std)
- `func main`: entry point of every program

### Prints

```go
package main
import "fmt"   // format package

func main() {
    // print without fmt seems also work, syntax sugar?
    print("hello world\n")
    println("hello world")

    // use fmt.Printxx
    fmt.Print("hello world\n")
    fmt.Println("hello world") // Println add \n

    // formatted print
    var smsSendLimit int
    var costPerSMS float64
    var hasPersmission bool
    var username string

    fmt.Printf("%v %f %v %q",
      smsSendLimit,
      costPerSMS,
      hasPersmission,
      username,
    )

    // Sprint family return the formatted strping
    info := fmt.Sprintf("%v %f %v %q",
      smsSendLimit,
      costPerSMS,
      hasPersmission,
      username,
    )
    info := fmt.Sprintln("hello world")

    // print concatenation
    conferenceName := "Go Conference"
    // use "+", or ","
    fmt.Println("Welcome to the " + conferenceName + ", I hope you a good afternoon.")
    fmt.Println("Welcome to the ", conferenceName, ", I hope you a good afternoon.")

}
```

- [printing](https://pkg.go.dev/fmt@go1.21.1)

  - `no brainer`
    - `%v` the value in a default format
    - `%T` a Go-syntax representation of the type of a variable
  - int
    - %d integer in base 10
  - bool
    - %t the word true or false
  - float
    - %e scientific notation, e.g. -1.234456e+78
    - %f decimal point
  - string
    - %s the uninterpreted bytes of the string
    - %q a double-quoted string

### user input: fmt.Scan()

```go
var userName string

// pass the address of userName
// will wait for user input
fmt.Scan(&userName)

fmt.Println("the address of userName is: ", &userName)
fmt.Println("user name is: ", userName)
```

# Variables

### `basic types`

- unless there is good reason, stick to the `default types`

  - bool
  - string
  - int
  - uint32
  - float64
  - byte, rune

- what are there (ALL)

  - bool
  - string
  - int, uint(unsigned). (int have platform-dependent size)
    - int8, int16, int32, int64
    - uint8, uint16, uint32, uint64
    - byte - alias of uint8
    - rune - alias of int32
  - float32, `float64` (float64 is the default float)
  - complex64, complex128 (imaginary number, less used)

- number operators:
  - -=, +=
  - ++, --
  - \*, /, %

### `Variable Declaration`

```go
// := short assignment, syntax suger
  // const can't use :=
username := "aa"
  // short assignment will allow redeclaration of same var provided:
    // it is multi-value short assignment
    // at least one var is new

  n1, err := strconv.Atoi("1")
  n2, err := strconv.Atoi("2")
  // this compiles
  // since n2 is new, err will be overriden


// var/const formal assignment
var username string = "aa"
var hasPersmission bool = false
const PI float64 = 3.14159265359

// type can be inferred, := short assignment is also inferred
var smsSendLimit = 50  // int
var costPerSMS = 1.0 // float64
```

- variable can be `declared without value`
  - `default values` (0, 0.0, "", false...) will be given

```go
var smsSendLimit int   // 0
var hasPersmission bool // false
```

### Get Type

- use `printf: %T`
- use the `reflect` package

  - reflect.TypeOf(var)

- 10 will be seen as int, 10.0 will be seen as float64

```go
package main
import (
    "fmt"
    "reflect"
)

x := 10
fmt.Printf("%T", x)
fmt.Printf("Type of x: %s\n", reflect.TypeOf(x))
```

### Type cast

- typeName(var)
  - boolean and int is `not convertable`
  - int and float is `convertable`
  - string and rune/byte slice are `convertable`

```go
// Convert string to []byte
str := "Hello, Golang"
byteslice := []byte(str)

// numeric are convertiable
numberF := 10.1
numberI := 10

fmt.Println(int(numberF))  // 10
fmt.Printf("%f", float64(numberI))  // 10.000
```

- convert between numeric and string require external functions in strconv
  - strconv.Atoi: string to int
  - strconv.ParseFloat: string to float
  - strconv.Itoa: int to string
  - strconv.FormatFloat: float to string

```go
// string/number conversion
import (
"fmt"
"strconv"
)

// strconv.Atoi
strNum := "123"
num, err := strconv.Atoi(strNum)  // int


// strconv.ParseFloat
strNum := "123.45"
num, err := strconv.ParseFloat(strNum, 64) //  float64

// strconv.Itoa
num := 12345
str := strconv.Itoa(num)  // string

// strconv.FormatFloat
num := 123.45
str := strconv.FormatFloat(num, 'f', -1, 64)   // string
```

# Pointers

- `pointer` is a variable
  - the variable store the `address` to a variable

```go
// pointer variable declaration is like *type
var strPointer *string = &userName
var intPointer *int = &num
```

- `* Operator` (dereferencing operator)
  - part of pointer typeName
  - used to access the value of an address
- `& operator` (address operator)
  - &var: return a pointer to a variable

```go
var userName string = "aa"
var userNamePointer *string = &userName

// & address
fmt.Println("the address of userName is: ", &userName)  // 0xc000104020
fmt.Println("the address of userName is: ", userNamePointer)  // 0xc000104020
fmt.Printf("the type of pointer %T", &userNamePointer)  // *string

// * dereference
fmt.Println("value through deref: ", *userNamePointer)  // "aa"
fmt.Println("the type of derefed pointer: %T", *userNamePointer)  //string
```

- default value(zero-value) of a pointer is `nil`

```go
var pointer *int
fmt.Println(pointer) // <nil>
```

- `:=` always allocate new memory

```go
x := 5
println(&x)  // 0xc000050728
x = 2
println(&x)  // 0xc000050728
y := x
println(&y)  // 0xc000050720
```

# Containers

- built-in
  - Slices
    - dynamically-sized
    - can have slices of slices ([][]int)
    - Strings are actually read-only slices of bytes
  - Maps
  - Arrays
    - fix sized, almost never used
  - channel
- standard lib
  - Heap (priority queue)
  - List (double linked-list)
  - more...

### heterogeneous types container

- it is `not common and not encouraged` to have heterogeneous types container
  - Go is statically typed, encourages strong type safety
  - a container typically expected a specific, known type.
- it is `still possible` to create heterogeneous types container by using an `interface type`

```go
package main

import "fmt"

func main() {
    // Create a slice of empty interfaces
    var mixedTypes []interface{}

    // Add elements of different types
    mixedTypes = append(mixedTypes, 42)           // int
    mixedTypes = append(mixedTypes, "Hello, Go")  // string
    mixedTypes = append(mixedTypes, 3.14)         // float64
    mixedTypes = append(mixedTypes, true)         // bool

    // Iterate over the slice and perform type assertion to access elements
    for _, item := range mixedTypes {
        switch value := item.(type) {
        case int:
            fmt.Printf("Integer: %d\n", value)
        case string:
            fmt.Printf("String: %s\n", value)
        case float64:
            fmt.Printf("Float: %f\n", value)
        case bool:
            fmt.Printf("Boolean: %t\n", value)
        default:
            fmt.Println("Unknown type")
        }
    }
}

```

### built-in container functions

```go
len(container)  // return the length of container
cap(slice)  // return capacity of slice
append(slice, newElem)
// make is a built-in function: allocates and initializes an object of type slice, map, or channel
make(map[string]int)
delete(map, "key")
```

## Container Types

### Arrays:

```go
// varNames [size]type
var numbers [20]int
numbers := [20]int

for i := 0; i < len(numbers); i++ {
    numbers[i] = i
}
fmt.Println(numbers)
```

### Slices

- slices are implemented as a `dynamic view` to an `underlying array`. slices don't own the data, the underlying array does.
  - view :=
    - pointer to first elem
    - current length
    - capacity
  - dynamic
    - if capacity is exceeded,
      - automatically create new Arrays
      - copy data to new array
      - update Slices' view
- [package slice apis](https://pkg.go.dev/slices)
  - defines various functions useful with slices of any type

```go
// slice is built on top of Arrays
numArray := [6]int{1,2,3,4,5,6}
numSlice := numArray[1:4]
numSlice := numArray[:5]

// Declaration: varNames []type
var numbers []int
numbers := []int

// slice with init value
numbers := []int{1, 2, 3, 4, 5}

// create slice with make: pre-allocate space
  // make will fill slice with 0
numbers := make([]int, 2)   // slice of length 2, capacity default to length
numbers := make([]int, 5, 10)   // slice of length 5 and capacity 10


// append to the end
numbers = append(numbers, 3, 4, 5) // append any number of args (Variadic)

// to prepend an elem you have to create a new slice
originalSlice := []int{3, 4, 5}
newSlice := append([]int{1, 2}, originalSlice...)
fmt.Println(newSlice)

  // ... spread syntax unpack the elements of the original slice.
```

- slice of slices

```go
w := make([][]string, 2)

w1 := make([]string, 3)
w1[0] = "war"
w1[1] = "water"
w1[2] = "wrath"

w2 := make([]string, 1)
w2[0] = "boy"

w[0] = w1
w[1] = w2
fmt.Println(w)
```

### Maps

- Slices(Arrays), Maps, Functions cannot be used as key
  - they are not comparable

```go
// Declare a map with string keys and int values
var personAge map[string]int

// Initialize the map
personAge = make(map[string]int)

// Map Literal Initialization
var personAge = map[string]int{
  "Alice":25,
  "Bob":25,
  "Karl":21,
}

// Add key-value pairs to the map
personAge["Alice"] = 25
personAge["Bob"] = 30

// access key
personAge["Eve"]

// delete key
delete(personAges, "Bob")

// Check key existance in Map
value, exists := personAge["Eve"]
if exists {} else {}

// attempt to access non-exist key in a map will return zero-key
// still, it is safer to use a check like above
personAge["Evea"] // 0 since value: int

// loop through a map
for key, value := range myMap {
  fmt.Printf("key: %v, value: %v\n\n", key, value)
}
```

- map of map

```go
hits := make(map[string]map[string]int)
// key: string
// value: map[string]int
```

- struct type key
  - use when: (multiple fields identify one Value)
  - struct: store multiple fields

```go
type Key struct {
  Url, Country string
}
hits := make(map[Key]int)
hits[Key{"/", "Vietnam"}] = 0
```

- implement `set` as map❗
  - attempt to access non-exist key in a map will return zero-key (0, false, "", nil ...)
  - `a set` can be implemented as `a map with bool value`

```go DOING
type Set interface {
  Add(item string)
  Remove(item string)
  Contains(item string) bool
  Print()
}
// define a StringSet
type StringSet struct {
  set map[string]bool
}

func (s StringSet) Add(item string) {
  s.set[item] = true
}
func (s StringSet) Contains(item string) bool {
  return s.set[item]
}
func (s StringSet) Remove(item string) {
  delete(s.set, item)
}

stringSet := StringSet{make(map[string]bool)}
StringSet.Add("Apple")   // Apple,
StringSet.Add("Banana")  // Apple, Banana
StringSet.Contains("Banana")  // true
StringSet.Remove("Banana")      // Apple
```

# Logic Flow

## loop

- golang doesn't have built-in `while`/ `do-while`/ `for-each` structures, but all achievable.
- controlling structures
  - `continue`
  - `break`

### `vanilla for`

- for INITIAL; CONDITION; STEP

```go
numbers := []int{1, 2, 3, 4, 5}
for i := 0; i < len(numbers); i++ {
    fmt.Printf("Index: %d, Value: %d\n", i, numbers[i])
}
```

### `for-each` structure

```go
// iterate over a slices
numbers := []int{1, 2, 3, 4, 5}
for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}

// iterate over a map
person := map[string]int{
    "Alice": 30,
    "Bob":   25,
}
for key, value := range person {
    fmt.Printf("Name: %s, Age: %d\n", key, value)
}

// iterate over channels
ch := make(chan int)
go func() {
    for i := 0; i < 5; i++ {
        ch <- i
        time.Sleep(time.Millisecond * 500) // Simulate some work
    }
    close(ch)
}()
for value := range ch {
    fmt.Printf("Value: %d\n", value)
}
// if a return in not need, use a `blank identifier`
for _, item := range numbers {}
```

### `do-while`, `while`

```go
// while true
for {
  if exitCondition {
    break
  }
  // business logic
}

// do-while
for {
  // business logic
  if exitCondition {
    break
  }
}

// while
for CONDITION {
  // run while CONDITION is true
}
```

## Conditional Structure

- golang provides
  - `if - else if - else`
  - `switch`
- golang `don't have ternery` structure
- logical stuffs
  - ==, <, >, <=, >=
  - &&, ||, !

### if - else if - else

```go
score := 85

if score >= 90 {
    fmt.Println("A")
} else if score >= 80 {
  fmt.Println("B")
} else {
  fmt.Println("C")
}
```

- syntax suger: `initial statement`
  - the variables created inside `initial statement` are `only exist in the if's scope`

```go
// instead of
err := json.Unmarshal(body, &person)
if err != nil {...}  // handle err

// you can write
if err := json.Unmarshal(body, &person); err != nil {...}  // handle err
```

### `switch`

```go
day := "Monday"
switch day {
case "Monday":
    fmt.Println("It's Monday.")
case "Tuesday":
    fmt.Println("It's Tuesday.")
default:
    fmt.Println("It's not Monday or Tuesday.")
}
```

# Functions

### Function Signature

- the `type of input and return` can be specified in Function Signature

```go
func add(a string, b int) int {}

func createUser(firstName, lastName string, age int) bool {}


func divide(dividend, divisor int) (int, int) {
    // ...
    return quotient, remainder
}

// you can also use `named return value`
  // main purpose: for reader to understand the func
  // width and height will be init automatically with 0
  // the TWO VARIABLE `width` and `height` by themselves are not required to be returned though... weird!
func measuring(shapeId string) (width, height int) {}
```

### `Variadic`

- `Variadic Functions`: function can accept a variable number of input. `...typeName`
  - inputs are received as a `slice` (think buffer that accept multiple args)
  - accsss Variadic args with `range`
  - `...` is called `Spread Operator`
  - `...typeName` can only be used as final parameter in input list

```go
func sumMultiple(baseNumStr string, numbers ...int) int {
  baseNum, _ := strconv.Atoi(baseNumStr)
	for _, num := range numbers {
		baseNum += num
	}

	return baseNum
}
result := sumMultiple("100", 1, 2, 3, 4, 5)
println(result)
```

- `...`: `Spread Operator`
  - spread the content of a container

```go
names := []string{"bob", "karl", "alice"}
printStrings(names...)
```

### `First-Class Function:` Functions are Values

- Functions are Values (like javascript)

  - function can be assigned to variables
  - function can be `passed as arg` to functions, or`return` by functions

- when `First-Class Functions` aka callback functions used:

  - HTTP API handler
  - pub/sub model
  - onclick callback
  - more

- store function in variable

```go
// store function in variable
anonymousFunc := func() {
    fmt.Println("Nested function")
}
anonymousFunc()
```

- pass a function to another function

```go
// Define a function that takes an `operation` type as input
type operation func(int, int) int
func apply(oper operation, a, b int) int {
    return oper(a, b)
}
// Alternatively, the unnamed func don't need a type `operation`
func apply(oper func(int, int) int, a, b int) int {
    return oper(a, b)
}

// pass functions as arg to apply
add := func(a, b int) int {
    return a + b
}

multiple := func(a, b int) int {
    return a * b
}

println(apply(add, 3, 5))
println(apply(multiple, 3, 5))
```

### Func Arg passing

- `base types args are passed by value`.

  - it is done intentionally to promote safety, simplicity, and predictability

```go
func changeA(a int) {
  a = 12
}
a := 11
changeA(a)
println(a)   // 11
```

- containers args(`slice and map`) passes `header` by value

  - `header` includes information about the underlying data structure (length, etc)
  - the underline data is not copied
  - `func and the caller access the same chunk of memory`

```go
func checkMemory(ids []int, personAges map[string]int) {
	println("inside checkMemory:")
	println(ids)
	println(personAges)
}

func main() {
	ids := []int{1, 2, 3, 1, 5}
	personAges := make(map[string]int)
	println(ids)
	println(personAges)
	checkMemory(ids, personAges)
}

// output
  // [5/5]0xc000050608
  // 0xc000050630
  // inside checkMemory:
  // [5/5]0xc000050608
  // 0xc000050630
```

- slice header includes:
  - slice's length, capacity, and a pointer to the underlying array
  - `appending to slice will not` affect the original
  - `changing to the elements in the slice will` affect the original
- to append a slice inside a func:
  1. you can return the slice
  2. you can pass a pointer of the slice (not recommended)

```go
func changeSlice(ids []int) {
	ids[0] = 11
	ids = append(ids, 11)  // only inside function
}
ids := []int{1, 2, 3, 1, 5}
changeSlice(ids)
fmt.Println(ids)  // [11 2 3 1 5]

// sol: pass a slice pointer as arg1.
func changeSlice(id_p *[]int) {
	*id_p = append(*id_p, 11)
}
ids := []int{1, 2, 3, 1, 5}
changeSlice(&ids)
fmt.Println(ids)  // [1 2 3 1 5 11]

```

- map header includes:

  - keys pointer and value pointer
  - `Changes (Add, Delete, Update)` to key-value pair are `visible both inside and outside the function.`

```go
func changeMap(personAges map[string]int) {
	personAges["Alice"] = 8   // update
	delete(personAges, "Bob") // delete
	personAges["Karl"] = 25   // add
}

personAges := make(map[string]int)
personAges["Alice"] = 11
personAges["Bob"] = 22
changeMap(personAges)
for key, value := range personAges {
  fmt.Printf("Key: %v, Value: %v\n", key, value)
}

// update, delete, add are visible outside
// Key: Alice, Value: 8
// Key: Karl, Value: 25
```

### defer Keyword

- `defer func` schedule the function to be executed just before its enclosing function(parent) returns

  - typical use:
    - to close resources, cleanup database connections, files, etc
    - logging when function finish
    - unlocking mutexes

- example: file io

```go
// Open a file
file, err := os.Create("example.txt")
if err != nil {
    fmt.Println("Error:", err)
    return
}
defer file.Close() // Ensure the file is closed when main() exits

// Write to the file
_, writeErr := file.WriteString("Hello, world!")
if writeErr != nil {
    fmt.Println("Error writing to file:", writeErr)
    return
}
```

# Scope (TODO)

### Variables Scopes/Lifecycle

TODO: package level variables (unexported)
Exported variable(Public)
constant

# OOP❓Related: Type/ Structs/ Interfaces/

- OOP

  - go is not entirely OOP language, but incorporates some of the OOP principles
  - go support
    - `Struct`, similar to class: attributes
      - `composition` but not `inheritance`
    - `Interfaces`: define a set of methods that a type must implement
      - `polymorphism`
      - `loose coupling`
  - go don't support
    - `constructors or destructors`, instead, go relies on the use of `factory functions`
    - `method overloading or overriding`

- `type`: type is a `keyword` to creating custom type definitions

  - create data type aliases
  - create interface
  - create struct

```go
type MyInt int64
type Person struct {}
type Shape interface {}
```

## Struct

- `struct`: a struct is a `composite data type` that groups together variables with different data types

  - thinks structs: OOP classes
  - struct can have a set of attributes
  - struct can hava a set of methods associated with it
  - `embedded struct` behavior similar to `inheritance`

- `struct` is also how typically `json data` are formated in golang

### Struct: attributes and method

- `attributes` are defined inside struct body

  - struct body only contains attributes

- `methods` are defined outside struct body
  - `receiver` specify the target(owning) struct
  - a receiver is a `special parameter before the name of func`

```go
type Rectangle struct {
	Width  float64
	Height float64
}

// Define a method associate with the Rectangle struct
// `receiver`: r Rectangle
func (r Rectangle) Area() float64 {
	return r.Width * r.Height
}

func main() {
	// Create an instance of Rectangle
	rectangle := Rectangle{Width: 4.0, Height: 6.0}

	// Call the method on the Rectangle instance
	area := rectangle.Area()
	printf("Area: %f\n", area)
	printf("Width: %f\n", rectangle.Width)
	printf("Height: %f\n", rectangle.Height)
}
```

### Nested Struct

- syntax

```go
type Wheel struct {
  Radius int
  Material string
}

type Car struct {
  Make string
  Model string
  FrontWheel Wheel
  BackWheel Wheel
}

// alternatively:
type Car struct {
  Make string
  Model string
  FrontWheel struct {
    Radius int
    Material string
  }
  BackWheel struct {
    Radius int
    Material string
  }
}

car := Car{"ford", "f1", Wheel{15, "steel"}, Wheel{15, "steel"}}
println("car Model:", car.Model)
println("BackWheel Material:", car.BackWheel.Material)
```

### Embedded Struct (Composition vs Inheritance)

- `Embedded` Struct is a way to achieve `Composition`, similar effect to `Inheritance` in OOP
- `Embedded` Struct inherit `inferface implementation`!!!

```go
type Car struct {
	make string
	model string
}

// a Truck is a child of a Car
type Truck struct {
  Car    // Embedded Struct are similar to Nested Struct
  truckLoad int
}

// Child can access all fields of Embedded Struct directly
truck := Truck{
  Car: Car{
    make: "toyota",
    model: "camry",
  },
  truckLoad: 20,
}
println(truck.make + " " + truck.model)
```

- `Embedded` Struct inherit `inferface implementation`!!!
  - supposely struct A implements an interface X, and struct B embeds struct A, then struct B also implements interface X.
  - This is because
    - `interface satisfaction` is based on `method sets`,
    - when you embed a struct, `the methods set of the embedded struct is unioned` into the struct that embed.

```go
// interface X
type X interface {
    DoX()
}

// A implements X
type A struct{}
func (a A) DoX() {
    fmt.Println("A is doing X")
}

// B is a child of A (B embedded A)
type B struct {
    A
}

// B also implements X
b := B{}
b.DoX()   // b can call DoX directly

// b can be assigned to type X
var xIntf X = b
xIntf.DoX()
```

### Format Json Payload to Struct

- `struct` is also how typically `json data` are formated in golang

```go
import (
    "encoding/json"
    "net/http"
    "io/ioutil"
)
type Person struct {
    FirstName string `json:"first_name"`
    LastName  string `json:"last_name"`
    Age       int    `json:"age"`
}

func(w http.ResponseWriter, r *http.Request) {
  body, err := ioutil.ReadAll(r.Body)  // read json body from request
  var person Person  // Create an instance
  err := json.Unmarshal(body, &person);  // parsed json data as a struct
}
```

### Anonymous Struct (`less used feature`)

- its not so important,
- Anonymous Struct := don't assign a type to a struct instance.
  - Create a instance immediately after define an Anonymous Struct
  - `when to use`: `when there is no need for more than one instance` of the Struct

```go
aCar := struct {
  Make  string
  Model string
}{
  Make:  "tesla",
  Model: "model 3",
}
println(aCar.Make + " " + aCar.Model)

type Car struct {
  Make string
  Model string
  FrontWheel Wheel
  BackWheel Wheel
}
type Wheel struct {
  Radius int
  Material string
}
```

## `interface`

- interface `specifies a set of methods signatures` that a type must implement.

  - polymorphism
  - loose coupling

- interface in go is fufilled `implicitly`:

  - struct don't declare it `implement` an interface
  - any struct that implments all function signature in an interface `implicitly` implements the interface
  - it is possible to add methods to a struct and `unknowingly fulfill multiple interface`. `That is okay!`.

- to implements a method of interface,
  - the requirements are same:
    - number and type of arguments
    - number and type of returns
  - what is not required:
    - the name of arguments
    - the name of returns

```go
type Shape interface {
    Area() float64
    Perimeter() float64
}

type Circle struct {
    Radius float64
}
type Square struct {
    Width, Height float64
}

// Implement an Interface
// Since `Circle struct` implement the Area() and Perimeter() method
// And `Area() and Perimeter()` is required by `Shape` interface
// `Circle struct` satisfy `Shape` interface
func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}
func (c Circle) Perimeter() float64 {
    return 2 * 3.14 * c.Radius
}
// same goes to `Square struct`
func (s Square) Area() float64 {
    return s.Width * s.Height
}
func (c Square) Perimeter() float64 {
    return 2 * (s.Width + s.Height)
}

// Polymorphism
// func `CalculateArea` takes any type that satisfies the Shape interface.
func CalculateArea(s Shape) float64 {
    return s.Area()
}

circle := Circle{Radius: 5.0}
square := Square{Width: 5.0, Height: 5.0}
fmt.Printf("Circle area: %v", CalculateArea(circle))
fmt.Printf("Square area: %v", CalculateArea(square))
```

- `Example`: define an interface for a database connection
  - then there may be various database implementations that satisfy this interface

```go
type DatabaseConnection interface {
    Connect() error
    Query(query string) ([]byte, error)
    Close() error
}
```

-

### Empty Interfaces (interface{})

- `Empty Interfaces: interface{}`, can hold values of any type
  - interface{} `is implemented by any type` because there is no requirement
- this property makes Empty Interface a Generic Data Containers in various scenerio.
  - create functions that can work with different input types
  - Container of JSON Parsing of unknown types
  - ...

```go
func PrintValue(val interface{}) {
    fmt.Println("Value:", val)
}
```

- example: handle JSON data with dynamic structures or unknown types

```go
var jsonData interface{}
json.Unmarshal([]byte(`{"name": "Alice", "age": 30}`), &jsonData)
```

### Type Assertion

- use `type assertion` to

  - check whether an Interface holds a particular underlying type
  - and `cast it back to the type`

- `Type Assertion` often used with `switch`

- empty interface example

```go
// empty interface example
var myInterface interface{}
myInterface = "Hello, Go!"

str, ok := myInterface.(string)
if ok {
    fmt.Println("It's a string:", str)
}
```

- non empty interface example

```go
// non empty interface example

type Shape interface {
    Area() float64
    Perimeter() float64
}
type Circle struct {
    Radius float64
}
type Square struct {
    Length float64
}
// omit method declerations...

func printShapeArea(shape Shape) {
  // We don't know what shape is it. Maybe Circle?
  circle, ok := shape.(Circle)
  if ok {
      fmt.Printf("The Circle's area is: %v", shape.Area())
  }
  // or Square
  square, ok := shape.(Square)
  if ok {
      fmt.Printf("The Square's area is: %v", shape.Area())
  }

}
```

- `Type Assertion` often used with `switch`
  - pass `type` to the `Type Assertion`

```go
func printShapeArea(shape Shape) {
  switch s := shape.(type) {  // pass `type`
    case Circle:
        fmt.Printf("Circle Area: %f\n", s.Area())
    case Rectangle:
        fmt.Printf("Rectangle Area: %f\n", s.Area())
    default:
        fmt.Println("Unknown Shape")
  }
}
```

### Interface Composition:

- Go allows you to create new interfaces by combining existing ones
- General Guide: `write small interface:` as few methods as possible

```go
type Reader interface {
  Read() error
}

type Writer interface {
  Write() error
}

type File interface {
  Reader
  Writer
  Stat() (os.FileInfo, error)
}
```

# Error Handling (DOING)

- there is no try-catch block in Go
- `error type` is an `interface` with a single method: `Error() string`,

```go
type error interface {
    Error() string
}
```

- `dangerous function`: whenever func signature returns an error, we know it is a dangerous function.

```go
func aDangerousFunc () (result, error)
```

### `throw and handle error`:

- func that may encounter errors typically return `a variable err of type error`
  - `a built-in general-purpose error` can be created through the `errors package`
  - the caller is responsible to `check if the err is nil`

```go
import "errors"
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

result, err := Divide(10, 0)
if err != nil {
    fmt.Println("Error:", err)
} else {
    fmt.Println("Result:", result)
}
```

### `custom error type`

- By implementing the error interface, you can define your own error types.
- purpose

  - carry additional information about the error
  - define error type specific error handling functions..

- `carry additional information`:
  - you can `store structured data` inside an error to format the message better.

```go
type userError struct {
  userName string
  userId string
}

func (e userError) Error() string {
  return fmt.Sprintf("unable to get user: %v (id:%v)", e.userName, e.userId)
}

func sendError() (error) {
  return userError{
    userName: "mlpppp"
    userId: "123"
  }
}
```

- you can `handle errors differently` based on their `custom error types` by using `type assertions and a switch statement`

```go
// Custom Error: DivideZeroError
type DivideZeroError struct {
    Message string
}

func (e DivideZeroError) Error() string {
    return e.Message
}

type MyError struct {
    Message string
}

func (e MyError) Error() string {
    return e.Message
}


// func Divide definition
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, DivideZeroError{Message : "division by zero"}
    } else if a == 0 {
        return 0, MyError{Message : "I don't want a to be 0"}
    }
    return a / b, nil
}

// a function may throw many different Error types
// Handle errors based on their type
result, err := Divide(0, 1)
switch e := err.(type) {
case DivideZeroError:
    // Handle MyError specifically
    fmt.Println("You cannot divide zero")
case MyError:
    // Handle MyError
    fmt.Println(e.Message)
case nil:
    // No error, do nothing
default:
    // Handle all other error types
    fmt.Println("Unknown error:", err)
}
```

### `Error Propagation`

- In Go, the philosophy is to `handle errors where they occur`, and to `propagate errors up the call stack` to a level where they can be properly `logged or reported` to the user.

## Panic & Recover

- Panic are Checked Error (RuntimeException )

# [Generics](https://go.dev/doc/tutorial/generics) (TODO)

- Generics in Go aim to allow defining functions and data structures that can work with different types without sacrificing type safety.
