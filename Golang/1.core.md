# Prepare

- resources

  - [standard lib](https://pkg.go.dev/std)
  - learning

    - [very comprehensive tutorial](https://www.youtube.com/watch?v=un6ZyFkqFKo)
    - [24hour leetcode](https://www.youtube.com/watch?v=a3Aep-SygUA)
    - [11 small projects](https://www.youtube.com/watch?v=jFfo23yIWac)
    - [go microservice](https://www.youtube.com/watch?v=VzBGi_n65iU&list=PLmD8u-IFdreyh6EUfevBcbiuCKzFk0EW_)

- go

  - go is a` compiled language`, compile to native machine code.
  - runtime faster than interpret languages: `python, javascript, ruby`
  - rumtime similar to VM-based languages like `Java, C#`.
  - go tend to use much less memory
    - built-in `automatic GC`
    - go inject a runtime code in compile that integrated with GC functions
    - doesn't require the huge memory overhead of VM (like Java JVM)
  - go has `fastest compiling speed`
  - go is `strong typed and static typed`
  - powerful `Concurrency Model`
  - not entirely OOP
  - great for
    - APIs(thanks to concurrency model)
    - Microservices, great for containers (thanks to lightweightness)
    - Networking: (offers low-level network programming capabilities, UDP/TCPIP)
    - SystemOps, Data ETL... (efficiency)

### Components

- `module`: a project
- `package`: all go src files belongs to a package
- `func main`: entry point of every program

### Get Started

- [install](https://go.dev/doc/install)

```bash
# init

# Create a module (init a project), initialize a `go.mod` file
go mod init github.com/sugoiServal/<prj_name> # include a repo name for future release
```

- Compile

```bash
go build && ./<ModuleName>  # Compile the package and run the binary
# executable: (package with `main.go`) build an executable.
# library: (package without `main.go`) still compile, useful for checking for compile errors

go run main.go  # compiles and run the file (must include `main.go`)

go test  # Execute all test cases of the current package (files end with _test.go)

```

- Package management

```bash

go get github.com/redis/go-redis/v9 # Download and install a package

go mod vendor  # Copy all dependencies into the vendor directory:
  # if you vendor, you also want to commit the vendor folder

go mod tidy  # Add missing and remove unused modules:
```

- install: run go executable globally

```bash
# compile and install the executable to GOPATH/bin
go install github.com/pressly/goose/v3/cmd/goose@latest

# you'll need to add GOPATH/bin to PATH to use them globally
  # GOPATH will default to $HOME/go
# add the two line to .bashrc
export GOPATH="$HOME/go"
PATH="$GOPATH/bin:$PATH"
# run
source ~/.bashrc
```

### Naming convension

- in general: `camelCase/ CamelCase`

- `Package` Names: `one lowercase word` or `a short abbreviation`

```go
// package
package main
package utils
package http
```

- Exported (Public), Unexported (Private)
  - `Exported (Public)` variable: `exported` objects can be accessed from other packages.
    - starts with an `Uppercase` letter,
  - Unexported (Private) variable: unexported object can only be accessed within the same package
    - starting with a `lowercase` letter.

```go
// Exported
var MaxValue int
func CalculateSum(a int, b int) int
type Point struct {...}

// Unexported
var count int
func calculateAverage(numbers []int) float64
type point struct {...}
```

- types...

```go
// Interface/ Type/ const start with Uppercase
type User struct {...}
type Products []Product
type Reader interface {
    Read([]byte) (int, error)
}
const (
    MaxRetryCount = 3
    PI            = 3.14159265359
)
```

# fmt: console IO

- prints

```go
package main
import "fmt"   // format package

func main() {
    // print without fmt seems also work, syntax sugar?
    print("hello world\n")
    println("hello world")

    // use fmt.Printxx
    fmt.Print("hello world\n")
    fmt.Println("hello world") // Println add \n

    // formatted print (%v for general purpose)
    fmt.Printf("%v %f %v %q",
      smsSendLimit,         // var smsSendLimit int
      costPerSMS,           // var costPerSMS float64
      hasPersmission,       // var hasPersmission bool
      username,             // var username string
    )

    // Sprint family return the formatted string
    info := fmt.Sprintf("%v %f %v %q",
      smsSendLimit,
      costPerSMS,
      hasPersmission,
      username,
    )
    info := fmt.Sprintln("hello world")

    // print concatenation: "+", or ",
    conferenceName := "Go Conference"
    fmt.Println("Welcome to the " + conferenceName + ", I hope you a good afternoon.")
    fmt.Println("Welcome to the ", conferenceName, ", I hope you a good afternoon.")
}
```

- [printing](https://pkg.go.dev/fmt@go1.21.1)

  - `no brainer`
    - `%v` the value in a default format
    - `%T` a Go-syntax representation of the type of a variable
  - int
    - %d integer in base 10
  - bool
    - %t the word true or false
  - float
    - %e scientific notation, e.g. -1.234456e+78
    - %f decimal point
  - string
    - %s the uninterpreted bytes of the string
    - %q a double-quoted string

- Scan(): user input

```go
var userName string
fmt.Scan(&userName) // pass the address of userName
// wait for user input...

fmt.Println("the address of userName is: ", &userName)
fmt.Println("user name is: ", userName)
```

# Variables

### `basic types`

- unless there is good reason, stick to the `default types`

  - `bool`
  - `string`: immutable sequence of characters, indexable
  - `int` (int have platform-dependent default size)
  - `float64`
  - byte, rune

- what are there (ALL)

  - bool
  - string
  - int, uint(unsigned).
    - int8, int16, int32, int64
    - uint8, uint16, uint32, uint64
    - byte - `ASCII` char, alias of `uint8`
    - rune - `unicode` char, alias of `int32`
  - float32, `float64` (float64 is the default float)
  - complex64, complex128 (imaginary number, less used)

- number operators:
  - -=, +=
  - ++, --
  - `*`, `/`, `%`

### `Variable Declaration/Assignment`

```go
username := "aa"   // := short assignment, syntax suger (type is inferred)

// formal assignment (explicit type)
var username string = "aa"
var hasPersmission bool = false

// const:  can't use :=
const PI float64 = 3.14159265359
```

- variable can be declared without value. `default zero values` (0, 0.0, "", false...) will be given

```go
var smsSendLimit int   // 0
var hasPersmission bool // false
```

- `redeclaration`: it is possible to redeclare a same variable in short assignment (:=), provides that
  - it is multi-value short assignment
  - at least one var is new

```go
// since n2 is new, variable err will be redeclared
n1, err := strconv.Atoi("1")
n2, err := strconv.Atoi("2")
```

- `multiple assignments`: allow you to assign values to multiple variables in a single statement
  - right-hand side of the assignment are evaluated, and a temporary tuple is created to store result
  - value in the temporary tuple are simultaneously assigned to variables in the left hand side

```go
variable1, variable2, ..., variableN = expression1, expression2, ..., expressionN

// Swap elements without temp using multiple assignment
s[left], s[right] = s[right], s[left]
```

### Slicing Syntax

- resulting `newSlice` will include elements `from the start index` up to, but `not including, the stop index`.

- you can slice `slice` or `string`
  - slice syntax create a new slice sharing the `same underlying array` (If you modify elements in the new slice, it will affect the original slice).
  -

```go
newSlice := originalSlice[start:stop]

s := "abcdefgh"
fmt.Println(s[1:5]) // Prints "bcde"

// Omitting the start index (defaults to 0)
fmt.Println(s[:5])  // Prints "abcde"

// Omitting the stop index (defaults to len(s))
fmt.Println(s[2:])  // Prints "cdefgh"
```

### Get Variables' Type

- use `printf: %T`
- use the `reflect` package

  - reflect.TypeOf(var)

```go
package main
import (
    "fmt"
    "reflect"
)

x := 10
fmt.Printf("%T", x)
fmt.Printf("Type of x: %s\n", reflect.TypeOf(x))
```

### Type cast

- convertable

  - int and float are convertable
  - string and float/int are convertable with `strconv` package
  - string and rune/byte slice ([]byte, []rune) are `convertable`

- string and []byte

  - each byte is the ASCII values of each character in the string.
  - string is immutable, to mutate the string, you should convert it to a byte slice first, make the modifications, and then convert it back to a string.

```go
s := "babad"
[]byte(s)[1]  // 97: "a"

```

- boolean and int are `not convertable`

```go
// int/float cast
numberF := 10.1
numberI := 10
fmt.Println(int(numberF))  // 10
fmt.Printf("%f", float64(numberI))  // 10.000


// string/ numeric cast
  // strconv.Atoi: string to int
  // strconv.Itoa: int to string
  // strconv.ParseFloat: string to float
  // strconv.FormatFloat: float to string

import (
"fmt"
"strconv"
)

// strconv.Atoi
strNum := "123"
num, err := strconv.Atoi(strNum)  // int

// strconv.ParseFloat
strNum := "123.45"
num, err := strconv.ParseFloat(strNum, 64) //  float64

// strconv.Itoa
num := 12345
str := strconv.Itoa(num)  // string

// strconv.FormatFloat
num := 123.45
str := strconv.FormatFloat(num, 'f', -1, 64)   // string
```

### String Builder

- strings.Builder type helps build a string by appending characters/strings

```go
var builder strings.Builder  // Create a new instance of strings.Builder:

builder.WriteByte('a')  // Use WriteByte to append a single byte.
builder.WriteString("Hello, ")   // Use WriteString to append a string.

result := builder.String()  // Get the final string:
```

# Pointers

- `pointer` is a variable that store the `address` to a variable

- `* Operator` (dereferencing operator)
  - part of pointer typeName (`*Type`)
  - dereference: used to access the value of an address (`*var`)
- `& operator` (address operator)

  - &var: return a pointer of a variable

- notes
  - short assignment `x := &var` implys that x is a pointer

```go
// declare pointer
var str_p *string = &userName  // var userName string = "aa"
short_p := &num

// access pointer
fmt.Println("the address of userName is: ", str_p)  // 0xc000104020
fmt.Printf("the type of pointer %T", str_p)  // *string

// * dereference
fmt.Println("value after deref: ", *str_p)  // "aa"
fmt.Printf("the type of derefed pointer: %T", *str_p)  //string
```

- default value(zero-value) of a pointer is `nil`
  - `deref` a `nil pointer` will cause `runtime error(panic)`
  - To be safe, we should generally want to check if.a pointer is nil before deref it.

```go
var pointer *int
fmt.Println(pointer) // <nil>
fmt.Println(*pointer) // deref throws a panic

// check pointer before using it
if pointer != nil {
  fmt.Println(*pointer)
} else {
  return
}
```

### Memory pitfall

- whenever a variable is declared, a new memory is allocated.
  - `:=` always allocate new memory.
  - Assigning a variable to another is: allocated a new memory => copy

```go
x := 5
y := x
// the two are different
println(&x)   // 0xc0000506e0
println(&y)   // 0xc0000506d8

a := []int{1, 2, 3}
b := a
// the two are different
println(&a)   // 0xc000050718
println(&b)   // 0xc000050700
```

# Containers

- built-in
  - `Slices`: dynamically-sized
  - `Maps`: hash map
  - `channel`
  - Arrays: fix sized, almost never used
- standard lib

  - Heap (priority queue)
  - List (double linked-list)
  - more...

- `string` are actually read-only slices of bytes

- it is `not common and not encouraged to have heterogeneous types container`. A container typically expected a specific, known type.

### built-in container functions

```go
len(container)  // return the length of container

// slice
cap(slice)  // return capacity of slice
append(slice, newElem)

// make: a built-in function: allocates and initializes an object of type slice, map, or channel
make(map[string]int)
delete(map, "key")

// copy: copies elements from a src slice into a dst slice.
copy(dst, src []Type) int
```

## Container Types

- [package slice apis](https://pkg.go.dev/slices)

### Arrays:

```go
// varNames [size]type
var numbers [20]int
numbers := [20]int
numArray := [6]int{1,2,3,4,5,6}

for i := 0; i < len(numbers); i++ {
    numbers[i] = i
}
fmt.Println(numbers)
```

### Slices

- slices are implemented as a `dynamic view` to an `underlying array`. slices don't own the data, the underlying array does.
  - a view is a data structure: pointer to first elem, current length, capacity
- slices is dynamic. if the capacity is exceeded,

  - automatically create new Arrays
  - copy data to new array
  - update Slices' view

```go
// create slice
numbers := []int{1, 2, 3, 4, 5}

// create slice with make
numbers := make([]int, 2)   // slice of length 2, capacity default to length
numbers := make([]int, 5, 10)   // slice of length 5 and capacity 10

// Declaration: varNames []type
var numbers []int
numbers := []int

// slice slice
numSlice := numArray[1:4]  // right not included
numSlice := numArray[:5]
numSlice := numArray[:0]  // return empty slice


// append to the end
numbers = append(numbers, 3, 4, 5) //  Variadic: provide any number of args

// prepend: you have to create a new slice
originalSlice := []int{3, 4, 5}
newSlice := append([]int{1, 2}, originalSlice...)  // ... spread syntax: unpack the elements of a slice.
```

- two dimension slice

```go
w := make([][]string, 2)

w1 := make([]string, 3)
w1[0] = "war"
w1[1] = "water"
w1[2] = "wrath"

w2 := make([]string, 1)
w2[0] = "boy"

w[0] = w1
w[1] = w2
fmt.Println(w)
```

- pass slice pointers to functions if you are planning to append the slice
  - passing a slice by value: creates a copy of the slice header, can modify the slice, but cannot modify the slice header itself (eg, change reference, change length/Capacity, `Appending`...)
  - passing a slice by pointer: use slice header directly without copying, full capacity

```go
func changeSlice(id_p *[]int) {
	*id_p = append(*id_p, 11)
}
ids := []int{1, 2, 3, 1, 5}
changeSlice(&ids)
fmt.Println(ids)  // [1 2 3 1 5 11]
```

### Maps

- Slices(Arrays), Maps, Functions cannot be used as key
  - they are not comparable

```go
// Declare a map with string keys and int values
var personAge map[string]int

// Initialize the map
personAge = make(map[string]int)

var personAge = map[string]int{
  "Alice":25,
  "Bob":25,
  "Karl":21,
}

// Add key-value pairs to the map
personAge["Alice"] = 25
personAge["Bob"] = 30

// access key
personAge["Eve"]

// delete key
delete(personAges, "Bob")

// Check key existance in Map
value, exists := personAge["Eve"]
if exists {} else {}

// attempt to access non-exist key in a map will return zero-key
personAge["Evan"] // return 0 since value: int

// loop through a map
for key, value := range myMap {
  fmt.Printf("key: %v, value: %v\n\n", key, value)
}
```

- `map of map`

```go
hits := make(map[string]map[string]int)
// key: string
// value: map[string]int
```

- `struct type key`: store multiple keys in a struct
  - use when: multiple fields identify one Value (many to one)

```go
type Key struct {
  Url, Country string
}
hits := make(map[Key]int)
hits[Key{"/", "Vietnam"}] = 0
```

- `set` implemented as a map❗
  - `a set` can be implemented as `a map with bool value`
  - attempt to access non-exist key in a map will return zero-key (0, false, "", nil ...)

```go DOING
type Set interface {
  Add(item string)
  Remove(item string)
  Contains(item string) bool
  Print()
}
// define a StringSet
type StringSet struct {
  set map[string]bool
}

func (s *StringSet) Add(item string) {
  s.set[item] = true
}
func (s *StringSet) Contains(item string) bool {
  return s.set[item]
}
func (s *StringSet) Remove(item string) {
  delete(s.set, item)
}

stringSet := StringSet{make(map[string]bool)}
StringSet.Add("Apple")   // Apple,
StringSet.Add("Banana")  // Apple, Banana
StringSet.Contains("Banana")  // true
StringSet.Remove("Banana")      // Apple
```

# Logic Flow

## loop

- golang doesn't have built-in `while`/ `do-while`/ `for-each` structures, but all achievable.
- controlling structures
  - `continue`
  - `break`

### `vanilla for`

- for INITIAL; CONDITION; STEP

```go
numbers := []int{1, 2, 3, 4, 5}
for i := 0; i < len(numbers); i++ {
    fmt.Printf("Index: %d, Value: %d\n", i, numbers[i])
}
```

### `for-each` structure

```go
// iterate over a slices
numbers := []int{1, 2, 3, 4, 5}
for index, value := range numbers {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}

// iterate over a map
person := map[string]int{
    "Alice": 30,
    "Bob":   25,
}
for key, value := range person {
    fmt.Printf("Name: %s, Age: %d\n", key, value)
}

// iterate over channels
ch := make(chan int)
go func() {
    for i := 0; i < 5; i++ {
        ch <- i
        time.Sleep(time.Millisecond * 500) // Simulate some work
    }
    close(ch)
}()
for value := range ch {
    fmt.Printf("Value: %d\n", value)
}

// if a return in not need, use a `blank identifier`
for _, item := range numbers {}
```

### `do-while`, `while`

```go
// while true
for {
  if exitCondition {
    break
  }
  // business logic
}

// do-while
i := 0
for {
    // Codae to be executed in the loop
    fmt.Println(i)
    i++
    // Check the condition at the end of the loop
    if i >= 5 {
        break
    }
}

// while
i := 0
for i < 5 {
    fmt.Println(i)
    i++
}
```

## Conditional Structure

- golang provides
  - `if - else if - else`
  - `switch`
- golang `don't have ternery` structure
- logical stuffs
  - ==, <, >, <=, >=
  - &&, ||, !

### if - else if - else

```go
score := 85

if score >= 90 {
    fmt.Println("A")
} else if score >= 80 {
  fmt.Println("B")
} else {
  fmt.Println("C")
}
```

- `initial statement`: syntax suger
  - the variables created inside `initial statement` are `only exist in the if's scope`

```go
// instead of
err := json.Unmarshal(body, &person)
if err != nil {...}  // handle err

// you can write
if err := json.Unmarshal(body, &person); err != nil {...}  // handle err
```

### `switch`

```go
day := "Monday"
switch day {
case "Monday":
    fmt.Println("It's Monday.")
case "Tuesday":
    fmt.Println("It's Tuesday.")
default:
    fmt.Println("It's not Monday or Tuesday.")
}
```

# Functions

### Function Signature

- the `type of input and return` can be specified in Function Signature

```go
func add(a string, b int) int {}

func createUser(firstName, lastName string, age int) bool {}


func divide(dividend, divisor int) (int, int) {
    // ...
    return quotient, remainder
}

// you can also use `named return value`
  // main purpose: for reader to understand the func
  // width and height will be init automatically with 0
  // the TWO VARIABLE `width` and `height` by themselves are not required to be returned though... weird!
func measuring(shapeId string) (width, height int) {}
```

### `Variadic`

- `Variadic Functions`: function can accept a variable number of input. `...typeName`
  - inputs are received as a `slice` (think buffer that accept multiple args)
  - accsss Variadic args with `range`
  - `...` is called `Spread Operator`
  - `...typeName` can only be used as final parameter in input list

```go
func sumMultiple(baseNumStr string, numbers ...int) int {
  baseNum, _ := strconv.Atoi(baseNumStr)
	for _, num := range numbers {
		baseNum += num
	}

	return baseNum
}
result := sumMultiple("100", 1, 2, 3, 4, 5)
println(result)
```

- `...`: `Spread Operator`
  - spread the content of a container

```go
names := []string{"bob", "karl", "alice"}
printStrings(names...)
```

### `First-Class Function:` Functions are Values

- Functions are Values (like javascript)

  - function can be assigned to variables
  - function can be `passed as arg` to functions, or`return` by functions

- when `First-Class Functions` aka callback functions used:

  - HTTP API handler
  - pub/sub model
  - onclick callback
  - more

- store function in variable

```go
// store function in variable
anonymousFunc := func() {
    fmt.Println("Nested function")
}
anonymousFunc()
```

- pass a function to another function

```go
// Define a function that takes an `operation` type as input
type operation func(int, int) int
func apply(oper operation, a, b int) int {
    return oper(a, b)
}
// Alternatively, unnamed func
func apply(oper func(int, int) int, a, b int) int {
    return oper(a, b)
}


// pass functions as arg to the function `apply`
add := func(a, b int) int {
    return a + b
}

multiple := func(a, b int) int {
    return a * b
}

println(apply(add, 3, 5))
println(apply(multiple, 3, 5))

// pass anonymous function as arg
println(apply(func(x int, y int) int {
    if y == 0 return 0
    return x/y
  }, 3, 5))
```

### Func Arg passing

- `base types args are passed by value`.

  - it is done intentionally to promote safety, simplicity, and predictability

```go
func changeA(a int) {
  a = 12
}
a := 11
changeA(a)
println(a)   // 11
```

- containers args(`slice and map`) passes `header` by value

  - `header` includes information about the underlying data structure (length, etc)
  - the underline data is not copied
  - `func and the caller access the same chunk of memory`

```go
func checkMemory(ids []int, personAges map[string]int) {
	println("inside checkMemory:")
	println(ids)
	println(personAges)
}

func main() {
	ids := []int{1, 2, 3, 1, 5}
	personAges := make(map[string]int)
	println(ids)
	println(personAges)
	checkMemory(ids, personAges)
}

// output
  // [5/5]0xc000050608
  // 0xc000050630
  // inside checkMemory:
  // [5/5]0xc000050608
  // 0xc000050630
```

- slice header includes:
  - slice's length, capacity, and a pointer to the underlying array
  - `appending to slice will not` affect the original
  - `changing to the elements in the slice will` affect the original
- to append a slice inside a func:
  1. you can return the slice
  2. you can pass a pointer of the slice (not recommended)

```go
func changeSlice(ids []int) {
	ids[0] = 11
	ids = append(ids, 11)  // only inside function cause `ids` is rereferenced
}
ids := []int{1, 2, 3, 1, 5}
changeSlice(ids)
fmt.Println(ids)  // [11 2 3 1 5], not changed

// sol: pass a slice pointer as arg1.
func changeSlice(id_p *[]int) {
	*id_p = append(*id_p, 11)
}
ids := []int{1, 2, 3, 1, 5}
changeSlice(&ids)
fmt.Println(ids)  // [1 2 3 1 5 11]
```

- map header includes:

  - keys pointer and value pointer
  - `Changes (Add, Delete, Update)` to key-value pair are `visible both inside and outside the function.`

```go
func changeMap(personAges map[string]int) {
	personAges["Alice"] = 8   // update
	delete(personAges, "Bob") // delete
	personAges["Karl"] = 25   // add
}

personAges := make(map[string]int)
personAges["Alice"] = 11
personAges["Bob"] = 22
changeMap(personAges)
for key, value := range personAges {
  fmt.Printf("Key: %v, Value: %v\n", key, value)
}

// update, delete, add are visible outside
// Key: Alice, Value: 8
// Key: Karl, Value: 25
```

### defer Keyword

- `defer func` schedule the function to be executed just before its enclosing function(parent) returns

  - typical use:
    - to close resources, cleanup database connections, files, etc
    - logging when function finish
    - unlocking mutexes

- example: file io

```go
// Open a file
file, err := os.Create("example.txt")
if err != nil {
    fmt.Println("Error:", err)
    return
}
defer file.Close() // Ensure the file is closed when main() exits

// Write to the file
_, writeErr := file.WriteString("Hello, world!")
if writeErr != nil {
    fmt.Println("Error writing to file:", writeErr)
    return
}
```

### Closure Function

- is a concept in programming languages, including Go.

- A `closure` is a function that access variables from outside of its scope, even after its function scope has exited.
  - commonly used for encapsulation, data hiding, and creating functions with dynamic behavior.
  - Go allows defining closures
- the usage is not very common though

```go
func createCounter() func() int {
    count := 0

    // Closure function
    increment := func() int {
        count++
        return count
    }

    return increment
}

// since createCounter return a func that has reference to the variable count, the returned func still manage the variable after the func exit

counter := createCounter()
fmt.Println(counter()) // Output: 1
fmt.Println(counter()) // Output: 2
fmt.Println(counter()) // Output: 3
```

# OOP❓Related: Type/ Structs/ Interfaces/

- OOP: go is not entirely OOP language, but incorporates some of the OOP principles

- `Struct`, similar to class: attributes

  - `composition` but not `inheritance`

- `Interfaces`: define a set of methods that a type must implement

  - `polymorphism`
  - `loose coupling`

- go don't support

  - `constructors or destructors`, instead, go relies on the use of `factory functions`
  - `method overloading or overriding`

- `type` keyword: used to creat custom type definitions, includes
  - data type aliases
  - interface
  - struct

```go
type MyInt int64  // data type aliases
type Person struct {}  // struct
type Shape interface {}  // interface
```

## Struct

- `struct`: a struct is a `composite data type`. Similar to class
- struct can include

  - a set of attributes (define inside struct)
  - a set of methods associated with it (define outside struct)
  - `embedded struct` (to achieve `inheritance`)

- `struct` is also how typically `json data` are formated in golang

- Go automatically dereferences the pointer to a struct when accessing the attributes/methods

```go
// `attributes` are defined inside struct body
type Rectangle struct {
	Width  float64
	Height float64
}

// `methods` are defined outside struct body
func (r *Rectangle) Area() float64 {  // `receiver` specify the target(owning) struct: r *Rectangle
	return r.Width * r.Height
}


// using struct
func main() {
	// Create an instance of Rectangle
	rectangle := Rectangle{Width: 4.0, Height: 6.0}
	rectangle_p := &rectangle

	// Call the method on the Rectangle instance
	area := rectangle.Area()
	printf("Width: %f\n", rectangle.Width)
	printf("Height: %f\n", rectangle_p.Height)
}
```

- ❗Use `pointer recivers` instead of value recivers. A method with `pointer recivers` can modify attributes in the caller struct. A method with `value recivers` cannot

### Nested Struct

- syntax

```go
type Wheel struct {
  Radius int
  Material string
}

type Car struct {
  Make string
  Model string
  FrontWheel Wheel
  BackWheel Wheel
}

// alternatively:
type Car struct {
  Make string
  Model string
  FrontWheel struct {
    Radius int
    Material string
  }
  BackWheel struct {
    Radius int
    Material string
  }
}

car := Car{"ford", "f1", Wheel{15, "steel"}, Wheel{15, "steel"}}
println("car Model:", car.Model)
println("BackWheel Material:", car.BackWheel.Material)
```

### Embedded Struct (Composition vs Inheritance)

- `Embedded` Struct is a way to achieve `Composition`, similar effect to `Inheritance` in OOP
- `Embedded` Struct inherit `inferface implementation`!!!

```go
type Car struct {
	make string
	model string
}

// a Truck is a child of a Car
type Truck struct {
  Car    // Embedded Struct are similar to Nested Struct
  truckLoad int
}

// Child can access all fields of Embedded Struct directly
truck := Truck{
  Car: Car{
    make: "toyota",
    model: "camry",
  },
  truckLoad: 20,
}
println(truck.make + " " + truck.model)
```

- `Embedded` Struct inherit `inferface implementation`!!!
  - supposely struct A implements an interface X, and struct B embeds struct A, then struct B also implements interface X.
  - This is because
    - `interface satisfaction` is based on `method sets`,
    - when you embed a struct, `the methods set of the embedded struct is unioned` into the struct that embed.

```go
// interface X
type X interface {
    DoX()
}

// A implements X
type A struct{}
func (a *A) DoX() {
    fmt.Println("A is doing X")
}

// B is a child of A (B embedded A)
type B struct {
    A
}

// B also implements X
b := B{}
b.DoX()   // b can call DoX directly

// b can be assigned to type X
var xIntf X = b
xIntf.DoX()
```

### Format Json Payload to Struct

- `struct` is also how typically `json data` are formated in golang

```go
import (
    "encoding/json"
    "net/http"
    "io/ioutil"
)
type Person struct {
    FirstName string `json:"first_name"`
    LastName  string `json:"last_name"`
    Age       int    `json:"age"`
}

func(w http.ResponseWriter, r *http.Request) {
  body, err := ioutil.ReadAll(r.Body)  // read json body from request
  var person Person  // Create an instance
  err := json.Unmarshal(body, &person);  // parsed json data as a struct
}
```

### Anonymous Struct (`less used feature`)

- its not so important,
- Anonymous Struct := don't assign a type to a struct instance.
  - Create a instance immediately after define an Anonymous Struct
  - `when to use`: `when there is no need for more than one instance` of the Struct

```go
aCar := struct {
  Make  string
  Model string
}{
  Make:  "tesla",
  Model: "model 3",
}
println(aCar.Make + " " + aCar.Model)

type Car struct {
  Make string
  Model string
  FrontWheel Wheel
  BackWheel Wheel
}
type Wheel struct {
  Radius int
  Material string
}
```

## `interface`

- interface `specifies a set of methods signatures` that a type must implement.

  - polymorphism
  - loose coupling

- interface in go is fufilled `implicitly`:

  - struct don't declare it `implement` an interface
  - any struct that implments all function signature in an interface `implicitly` implements the interface
  - it is possible to add methods to a struct and `unknowingly fulfill multiple interface`. `That is okay!`.

- to implements a method of interface,
  - the requirements are same:
    - number and type of arguments
    - number and type of returns
  - what is not required:
    - the name of arguments
    - the name of returns

```go
type Shape interface {
    Area() float64
    Perimeter() float64
}

type Circle struct {
    Radius float64
}
type Square struct {
    Width, Height float64
}

// Implement an Interface
// Since `Circle struct` implement the Area() and Perimeter() method
// And `Area() and Perimeter()` is required by `Shape` interface
// `Circle struct` satisfy `Shape` interface
func (c *Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}
func (c *Circle) Perimeter() float64 {
    return 2 * 3.14 * c.Radius
}
// same goes to `Square struct`
func (s *Square) Area() float64 {
    return s.Width * s.Height
}
func (c *Square) Perimeter() float64 {
    return 2 * (s.Width + s.Height)
}

// Polymorphism
// func `CalculateArea` takes any type that satisfies the Shape interface.
func CalculateArea(s Shape) float64 {
    return s.Area()
}

circle := Circle{Radius: 5.0}
square := Square{Width: 5.0, Height: 5.0}
fmt.Printf("Circle area: %v", CalculateArea(circle))
fmt.Printf("Square area: %v", CalculateArea(square))
```

- `Example`: define an interface for a database connection
  - then there may be various database implementations that satisfy this interface

```go
type DatabaseConnection interface {
    Connect() error
    Query(query string) ([]byte, error)
    Close() error
}
```

-

### Empty Interfaces (interface{})

- `Empty Interfaces: interface{}`, can hold values of any type
  - interface{} `is implemented by any type` because there is no requirement
- this property makes Empty Interface a Generic Data Containers in various scenerio.
  - create functions that can work with different input types
  - Container of JSON Parsing of unknown types
  - ...

```go
func PrintValue(val interface{}) {
    fmt.Println("Value:", val)
}
```

- example: handle JSON data with dynamic structures or unknown types

```go
var jsonData interface{}
json.Unmarshal([]byte(`{"name": "Alice", "age": 30}`), &jsonData)
```

### Type Assertion `.(type)`

- use `type assertion` to

  - check whether an Interface holds a particular underlying type
  - if so, `cast it back to the type`
  - else throw an panics exception

- `Type Assertion` often used with `switch`

- empty interface example

```go
// empty interface example
var myInterface interface{}
myInterface = "Hello, Go!"

str, ok := myInterface.(string)
if ok {
    fmt.Println("It's a string:", str)
}
```

- non empty interface example

```go
// non empty interface example

type Shape interface {
    Area() float64
    Perimeter() float64
}
type Circle struct {
    Radius float64
}
type Square struct {
    Length float64
}
// omit method declerations...

func printShapeArea(shape Shape) {
  // We don't know what shape is it. Maybe Circle?
  circle, ok := shape.(Circle)
  if ok {
      fmt.Printf("The Circle's area is: %v", shape.Area())
  }
  // or Square
  square, ok := shape.(Square)
  if ok {
      fmt.Printf("The Square's area is: %v", shape.Area())
  }

}
```

- `Type Assertion` often used with `switch`
  - pass `type` to the `Type Assertion`

```go
func printShapeArea(shape Shape) {
  switch s := shape.(type) {  // pass `type`
    case Circle:
        fmt.Printf("Circle Area: %f\n", s.Area())
    case Rectangle:
        fmt.Printf("Rectangle Area: %f\n", s.Area())
    default:
        fmt.Println("Unknown Shape")
  }
}
```

### Interface Composition:

- Go allows you to create new interfaces by combining existing ones
- General Guide: `write small interface:` as few methods as possible

```go
type Reader interface {
  Read() error
}

type Writer interface {
  Write() error
}

type File interface {
  Reader
  Writer
  Stat() (os.FileInfo, error)
}
```

### heterogeneous types container

- it is `still possible` to create heterogeneous types container by using an `interface type`

```go
package main

import "fmt"

func main() {
    // Create a slice of empty interfaces
    var mixedTypes []interface{}

    // Add elements of different types
    mixedTypes = append(mixedTypes, 42)           // int
    mixedTypes = append(mixedTypes, "Hello, Go")  // string
    mixedTypes = append(mixedTypes, 3.14)         // float64
    mixedTypes = append(mixedTypes, true)         // bool

    // Iterate over the slice and perform type assertion to access elements
    for _, item := range mixedTypes {
        switch value := item.(type) {
        case int:
            fmt.Printf("Integer: %d\n", value)
        case string:
            fmt.Printf("String: %s\n", value)
        case float64:
            fmt.Printf("Float: %f\n", value)
        case bool:
            fmt.Printf("Boolean: %t\n", value)
        default:
            fmt.Println("Unknown type")
        }
    }
}
```

# Error Handling

- there is no try-catch block in Go
- `error type` is an `interface` with a single method: `Error() string`,

```go
type error interface {
    Error() string
}
```

- `dangerous function`: whenever func signature returns an error, we know it is a dangerous function.

```go
func aDangerousFunc () (result, error)
```

### `throw error`:

- func that may encounter errors typically return `a variable err of type error`
  - `a built-in general-purpose error` can be created through the `errors package`
  - the caller is responsible to `check if the err is nil`

```go
import "errors"
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

result, err := Divide(10, 0)
if err != nil {
    fmt.Println("Error:", err)
} else {
    fmt.Println("Result:", result)
}
```

### `custom error type`

- By implementing the error interface, you can define your own error types.
- purpose

  - carry additional information about the error
  - define error type specific error handling functions..

- `carry additional information`:
  - you can `store structured data` inside an error to format the message better.

```go
type userError struct {
  userName string
  userId string
}

func (e *userError) Error() string {
  return fmt.Sprintf("unable to get user: %v (id:%v)", e.userName, e.userId)
}

func sendError() (error) {
  return userError{
    userName: "mlpppp"
    userId: "123"
  }
}
```

- you can `handle errors differently` based on their `custom error types` by using `type assertions and a switch statement`

```go
// Custom Error: DivideZeroError
type DivideZeroError struct {
    Message string
}

func (e *DivideZeroError) Error() string {
    return e.Message
}

type MyError struct {
    Message string
}

func (e *MyError) Error() string {
    return e.Message
}


// func Divide definition
func Divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, DivideZeroError{Message : "division by zero"}
    } else if a == 0 {
        return 0, MyError{Message : "I don't want a to be 0"}
    }
    return a / b, nil
}

// a function may throw many different Error types
// Handle errors based on their type
result, err := Divide(0, 1)
switch e := err.(type) {
case DivideZeroError:
    // Handle MyError specifically
    fmt.Println("You cannot divide zero")
case MyError:
    // Handle MyError
    fmt.Println(e.Message)
case nil:
    // No error, do nothing
default:
    // Handle all other error types
    fmt.Println("Unknown error:", err)
}
```

### Handling errors with log

- use log package to log errors
- Fatal functions: log an error and terminate the program

```go
import (
	"log"
	"errors"
)
err := errors.New("This is an example error.")
log.Printf("Error: %v", err)
log.Fatal(err)
```

### `Error Propagation`

- In Go, the philosophy is to `handle errors where they occur`, and to `propagate errors up the call stack` to a level where they can be properly `logged or reported` to the user.

## Panic & Recover

- Panic and recover are mechanisms to deal with Runtime Exceptions
- `Stick to error interface` in general usage.
  - use panic and recover sparingly and only in situations where it is absolutely necessary (where the program cannot safely continue its execution).

### `Panic` (Panicking)

- a built-in function in Go
- used to cause a program to panic:
  - stop executing the current function
  - begin to unwind the call stack.
- for unrecoverable (often memory related) errors
  - division by zero
  - out-of-bounds array
  - nil pointer dereference

### `recover`

- a built-in function in Go

- used to `resume and regain control after a panic`.

  - typically used within a `defer func` in the context of panic
  - if you don't call recover, the program will terminate after a panic.

- `behavior`:
  - called in the context of panic
    - returns the `value(message) passed to panic`
  - called outside the context of panic
    - return `nil`

```go
func (x int, y int) float64 {
  defer func() {
    if r := recover(); r != nil {
      // recover() captures the panic message
      // and allows the program to continue executing
      fmt.Println("Recovered:", r)
    }
  }
  if x == 0 {
    panic("x cannot be zero")
  }
  // Rest of the code will not be executed if panic occurs

}
```

# [Generics](https://go.dev/doc/tutorial/generics)

- Generics in Go aim to allow defining `functions and data structures` that can work with different types (without sacrificing type safety).
  - this attribute is important when writing a library

```go
// we have to write same function for each type
func splitIntSlice(s []int) ([]int, []int) {
    mid := len(s)/2
    return s[:mid], s[mid:]
}

func splitStringSlice(s []string) ([]string, []string) {
    mid := len(s)/2
    return s[:mid], s[mid:]
}

// through Generic, we only need to define one function
  // [TypeParam/ Constraint]
func splitAnySlice[T any](s []T) ([]T, []T) {
    mid := len(s)/2
    return s[:mid], s[mid:]
}

// create a zero-value of T
var zeroVal T

```

- `T` is the name of the `type parameter` for the splitAnySlice function,
- T match the `any constraint`, which means it can be anything.

### Constraints

- Sometimes logic in your generic function need to know about the types it operates on.

- `Constraints` can limit the generic type to a subset, which satisfies the constraint
  - `any`: there is no constraint
  - a `interface`: a type that satisfies the interface

```go
type stringer interface {
    String() string
}

func concat[T stringer](vals []T) string {
    result := ""
    for _, val := range vals {
        // we know that stringer can String()
        result += val.String()
    }
    return result
}


//  create a constraint(interface) that include a list of primitive types
  // Ordered is a type constraint that supports the <, <=, >, and >=
type Ordered interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 |
        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
        ~float32 | ~float64 |
        ~string
}

func compare[T Ordered](a, b T) T {
    if a > b {
      return a
    } else {
      return b
    }
}
```

### TypeParam [] can also used in Interface

- `Purpose`:

  - specify the generic of interface method

- example
  - any product(toys, books) that satisfies product interface can be used in function Sell(P)
  - anything that is not a product cannot be passed to Sell(P)

```go
type store[P product] interface {
	Sell(P)
}

type product interface {
	Price() float64
	Name() string
}
```

- full snippet(略)

```go
// The store interface represents a store that sells products.
// It takes a type parameter P that represents the type of products the store sells.
type store[P product] interface {
	Sell(P)
}

type product interface {
	Price() float64
	Name() string
}

type book struct {
	title  string
	author string
	price  float64
}

func (b book) Price() float64 {
	return b.price
}

func (b book) Name() string {
	return fmt.Sprintf("%s by %s", b.title, b.author)
}

type toy struct {
	name  string
	price float64
}

func (t toy) Price() float64 {
	return t.price
}

func (t toy) Name() string {
	return t.name
}

// The bookStore struct represents a store that sells books.
type bookStore struct {
	booksSold []book
}

// Sell adds a book to the bookStore's inventory.
func (bs *bookStore) Sell(b book) {
	bs.booksSold = append(bs.booksSold, b)
}

// The toyStore struct represents a store that sells toys.
type toyStore struct {
	toysSold []toy
}

// Sell adds a toy to the toyStore's inventory.
func (ts *toyStore) Sell(t toy) {
	ts.toysSold = append(ts.toysSold, t)
}

// sellProducts takes a store and a slice of products and sells
// each product one by one.
func sellProducts[P product](s store[P], products []P) {
	for _, p := range products {
		s.Sell(p)
	}
}

func main() {
	bs := bookStore{
		booksSold: []book{},
	}

    // By passing in "book" as a type parameter, we can use the sellProducts function to sell books in a bookStore
	sellProducts[book](&bs, []book{
		{
			title:  "The Hobbit",
			author: "J.R.R. Tolkien",
			price:  10.0,
		},
		{
			title:  "The Lord of the Rings",
			author: "J.R.R. Tolkien",
			price:  20.0,
		},
	})
	fmt.Println(bs.booksSold)

    // We can then do the same for toys
	ts := toyStore{
		toysSold: []toy{},
	}
	sellProducts[toy](&ts, []toy{
		{
			name:  "Lego",
			price: 10.0,
		},
		{
			name:  "Barbie",
			price: 20.0,
		},
	})
	fmt.Println(ts.toysSold)
}

```

# Packages & Modules & Scope

- module - project
  - github release
  - be imported and used
- package - directory
  - executable or library
- scope:
  - exported: Uppercase
  - unexported: lowercase

### Design Clean Packages

- built `small and reusable` package
- hide internal logic (encapsulation). `Export as few as possible`
- `do not export any code` from the `main package`
- Do not change APIs(Exported Code). A well designed library will have a stable API.

## package

- package are essentially `directory`

  - a Module typically contains only one package
  - Functions, types variables defined in one file `are visible` to all other files `within the same package`.

- package types
  - `executable`: a package with `main.go` is compiled into executable
  - `library`: package without `main.go` is a library. A library is used by other Modules

### `import`

- After `importing a package`, you can use its
  - exported functions,
  - types,
  - variables
- `import path` of a package is like

```go
// standard lib: a path to the specific package
import "math/rand"

// external third-party sources, such as GitHub
import "github.com/mlpppp/rand"

// local package (relative to the current directory)
import "./mypackage"

// import with alias
import mypkg "github.com/mlpppp/mypackage"
```

- example:

```go
package main
import (
    "fmt"
    "github.com/gin-gonic/gin"
)
func main() {
    // Using the imported "fmt" package
    fmt.Println("Hello, world!")

    // Using the imported "gin" package
    router := gin.Default()
    router.GET("/hello", func(c *gin.Context) {
        c.String(200, "Hello, Gin!")
    })
    router.Run(":8080")
}
```

## Module

- a `Module` is a collection of packages for a specific purpose. A `git go repository` generally contains one Modules

- `think module` basically a project, a tool, a release of a src software, etc..

- for a Module that is not a standalone software, but intend to be used by other project, `there is no main.go`

```bash
# go mod init create a new module
go mod init <prj_name>
```

- a `go.mod` file will be in the root of a module, contains

  - module name and path
  - any external dependencies,
  - versions of golang

- in go, `there is no central repository like npm, pip or mvn`

  - most of time `modules are published through github/gitlab` and got downloaded through url

- example: [a public go module](https://github.com/redis/go-redis)

```bash
# go.mod file
module github.com/redis/go-redis/v9

go 1.18

# replace an package installation string with a local path, so go won't fetch it from Internet, but locally
replace github.com/mlpppp/myApp v0.0.0 => ../myApp

require (
	github.com/bsm/ginkgo/v2 v2.12.0
	github.com/bsm/gomega v1.27.10
	github.com/cespare/xxhash/v2 v2.2.0
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f
  github.com/mlpppp/myApp v0.0.0
)

# for enduser

# bash: install a module
go get github.com/redis/go-redis/v9
  # new require field will be added to go.mod

# then use the package in .go
  # can use alias
import (
    "fmt"
    goredis "github.com/redis/go-redis/v9"
)
```

## Scopes: Exported and Unexported

- `exported`: names that start with an Uppercase letter are exported and can be accessed from other packages
- `unexported`: names that start with a lowercase letter are unexported and can only be accessed within the same package

```go
// Exported variable
  // access ExportedVariable as packagename.ExportedVariable
var ExportedVariable int = 42

// Unexported variable
var unexportedVariable int = 24

// Exported constant
const ExportedConstant = 42

// Unexported constant
const unexportedConstant = 24

// Exported type
  // can create variables of type ExportedType in other packages
type ExportedType struct {
    Field1 int
    Field2 string
}

// Unexported type
  // often used to encapsulate implementation details within a package.
type unexportedType struct {
    Field1 int
    Field2 string
}

// Exported function
  // call packagename.ExportedFunction() from other packages
func ExportedFunction() {
    // ...
}

// Unexported function
  // often used for internal logic
func unexportedFunction() {
    // ...
}
```

# Math functions
